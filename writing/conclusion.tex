\chapter{Conclusion and Future Work}
In this report, we have presented a new algorithm for computing a discrete path that satisfies a given LTL formula. Like the accepted algorithm, we represent the LTL formula as a B\"uchi automaton, and the robot's motion as a finite-state transition system. The product of these two graphs is then searched to find an accepting path, which is a path that passes through an accepting node an infinite number of times. 

The novel idea of the greedy algorithm is the injection of distance information into the B\"uchi automaton. Then when searching the product automaton, we are able to follow a path of decreasing distance to the accepting nodes. We have seen in this thesis that the greedy algorithm produces a path faster than the accepted algorithm, although in general it does not produce the optimal path. For two common formula types (reachability while avoiding regions and sequencing), the greedy algorithm will produce the optimal path in a shorter time than the accepted algorithm. We have also shown that for other more complex formulas, such as Example 1 in the Chapter 5 the greedy algorithm is guaranteed to give the optimal path in a shorter amount of time than the accepted algorithm. 

The problem with the greedy algorithm is that thorough analysis of the B\"uchi automaton is needed to predict the algorithm performance. This is troubling because one advantage of automated path generation is that one does \textit{not} need to analyze the task. Future work should focus on analyzing more formulas in a generic form to provide a general rule about the greedy algorithm's performance on formulas of a certain type. It is too much work to analyze each formula individually.    

For coverage formulas we have derived a bound on the cost of the path computed by the greedy algorithm in terms of the cost of the optimal path. However, it can be a very loose bound in general. Future work could be done on tightening this bound, and also on finding bounds for formulas of other types. Even though our bound is loose, it still makes the greedy algorithm more attractive. We note in the section on Recurrence Formulas that the accepted algorithm is also not guaranteed to produce the optimal path when the B\"uchi automaton is not tight. This means that the optimal path is not necessarily needed and provides a reason to use the greedy algorithm.

Besides the cost of the calculated run, we also looked at the time it takes both algorithms to calculate the runs. The greedy algorithm was faster in every example. We are not aware of any circumstances in which the accepted algorithm computes a path faster, and it is likely that it never will. However, the bottleneck of both algorithms is usually not the search, it is the construction of the product automata. In some situations, the search time is around a hundredth of the time to construct the product automaton; this is true even for the greedy algorithm. It seems that future work should then instead focus on reducing the size of the product automaton, or the time it takes to construct it. One way to do this would be to adapt the greedy algorithm to on-the-fly construction. 

It is true that the construction of the product automaton usually takes up the majority of the running time of the algorithm, except in the situation with non-trival suffixes. We saw in Modified Example 2 in Chapter 5 that sometimes an incredibly large amount of time can be spent calculating the paths from the accepting nodes back to themselves. The greedy algorithm is safe from this as it does not calculate the shortest path from \textit{all} accepting nodes back to themselves. 

Overall, the greedy algorithm produces an accepting path faster than the accepted algorithm. However, it is not guaranteed to be optimal. The accepted algorithm is also not guaranteed to be optimal unless the B\"uchi automaton is tight, but the greedy algorithm can never produce a cheaper cost than the accepted algorithm. There are certain types of formulas that the greedy algorithm will perform better on than the accepted. However, besides these formulas it can be hard to analyze the performance of the greedy algorithm. When deciding which algorithm to use, one should weigh the importance of optimality and speed. The greedy algorithm is faster. However, given that the overwhelming majority of time is spent constructing the product automaton, our increased speed in the search may not be helpful.  