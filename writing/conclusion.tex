\chapter{Conclusion and Future Work}
In this report we have presented a new algorithm for computing a path that satisfies a given LTL formula. Like the accepted algorithm we also represent the LTL formula as a B\"uchi automaton, and the robot's motion as a finite transition system. The product of these two graphs is then searched to find an accepting path, which is a path that passes through an accepting node an infinite number of times. 

The novel idea of our algorithm is the injection of distance information into the B\"uchi automaton. Then when we search the product automaton, we are able to follow a path of decreasing distance to the accepting nodes. We have seen in the report that our algorithm produces a path faster than the accepted algorithm, although in general it does not produce the optimal path. For two common formula types (reachability while avoiding regions and sequencing) that our algorithm will produce the optimal path in a shorter time than the accepted algorithm. We have also shown that for other more complex formulas, such as example 1 in chapter Complex Formulas our algorithm is guaranteed to give the optimal path in a shorter amount of time than the accepted algorithm. The problem with this is that this required a thorough analysis of the problem and the B\"uchi automaton. This seems like it could be more trouble than it is worth in a practical setting, because one of the main advantages of this method of automated path generation is that one does \textit{not} need to analyse and reason about the task. Also the problem we did this with was less complex than it could have been. Future work should focus on analysing more formulas in a generic form to provide a general rule on how our algorithm performs on formulas of a certain type. It is too much work to analyse each formula individually.    

For coverage formulas we have derived a bound on the cost of the path computed by our algorithm and the optimal path, however it can be a very loose bound in general. Future work could be done of tightening this bound, and also on finding bounds for formulas of other types. Even though our bound is loose, it still makes our algorithm more attractive. If the is no guarantee that our algorithm is not going to produce a path that is incredibly long compared to the accepted algorithm then it can make people nervous to use it. We note in the section of Recurrence formulas that the accepted algorithm is also not guaranteed to produce the optimal path when the B\"uchi automaton is not tight. This means that the optimal path is not necessarily needed and provides a reason to use our algorithm.

Besides the cost of the calculated run, we also looked at the time it takes both algorithms to calculate the runs. Our algorithm was faster in every example. We are not aware of any circumstances in which the accepted algorithm computes a path fast, and it is likely that it will not. However, the bottleneck both these algorithms is usually not the search, it is the construction of the product automata. In some situations, the search time is around a hundredth of the time to construct the product automaton; this is true even for the accepted algorithm. It seems that future work should then instead focus on reducing the size of the product automaton, or the time it takes to construct it. 

It is true that the construction of the product automaton usually takes up the majority of the running time of the algorithm, except in the situation with non-trival suffixes. We saw in the modified example 2 in the complex formulas chapter that sometimes an incredibly large amount of time can be spent calculating the paths from the accepting nodes back to themselves. Our algorithm is safe from this as it does not calculate the shortest path from \textit{all} accepting nodes back to themselves. 

Overall our algorithm produces an accepting path faster than the accepted algorithm, however it is not guaranteed to be optimal. The accepted algorithm is also not guaranteed to be optimal unless the B\"uchi automaton is tight, but our algorithm can never produce a cheaper cost than the accepted algorithm. There are certain types of formulas that our algorithm will perform better on than the accepted, however besides these formulas it can be hard to analyse the performance of our algorithm. When deciding which algorithm to use, one should weigh the importance of optimally and speed. Our algorithm is faster, however given that the overwhelming majority of time is spent constructing the product automaton, our increased speed in the search may not be very attractive or helpful.  