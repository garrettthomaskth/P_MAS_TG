\chapter{Introduction}
\section{Problem}
The use of formal methods, specifically \textit{model checking}, in control planning synthesis is a new and exciting research area. Formal methods are originally mathematical techniques to specifiy and verify the design of software and hardware \cite{clarke96}. \textit{formal verification} methods ensure that there are no bugs present in the software or hardware design which will cause unexpected behaviors. This is needed because other debugging techniques such as simulation and testing only ensure that there are no problems with a given the input. Bugs that go undetected can have disastrous effects, such as the explosion of the Ariane 5 rocket in 1996, which was caused by an exception being thrown when a 64-bit floating point number was converted to a 16-bit signed integer \cite{clarke99}. 

%This is however not what model checking was originally designed for. Model checking was designed as a method for . When designing software or hardware one wants to make sure that it does what it is supposed to do, and that there are no bugs in the program which will cause unexpected behaviors. These bugs can have disastrous effects, such as the explosion of the Ariane 5 rocket in 1996, which was caused by an exception being thrown when a 64-bit floating point number was converted to a 16-bit signed integer \cite{clarke99}. 
Model checking is an approach to formal verification which decides if a model of the program satisfies some behavior. These behaviors can be given as a temporal logic formula, commonly linear temporal logic (LTL) or computation tree logic (CTL). Since its advent, model checking under temporal logics has proved to be a very useful tool in software and hardware development. There are commercial and open source model checkers available \cite{holzmann03}, \cite{cimatti02} and many companies have their own in house model checking programs. 

Two main benefits of model checking are that 1) it is completely autonomous; after the program is modelled and the behavior is formalized into temporal logic, the model checker is self sufficient and no longer requires user interaction and 2) in the situation when the model fails to satisfy the given formula, a counter example is given (\textit{why} the model does not satisfy the specification). 

%The latter property gives valuable information for debugging purposes, and also 
It is obvious to see how the counter example gives valuable information for debugging purposes. This counter example however has also given rise to the new and exciting field of model planning as a tool for control planning synthesis. In this field of motion and task planning, the model of the program is replaced by a model of the robot's environment and the formula is the \textit{negation} of the desired robot motion and tasks. The realization that the double negative of a \textit{counter example} of the \textit{negation} of the desired motion was in fact the desired motion is the basis of this field. Earlier works in this field have even used the same programs that were designed for classic model checking \cite{fainekos05}. %spin is used in blah blah blah papers

Model checking however is not perfect. It suffers from what is known as the \textit{state-space explosion problem}. This is a phenomenon in which the number of states can quickly grow to an unmanageable number rendering the model checking uncomputable. Neither classical model checking or the application of model checking in motion planning is safe from the state explosion problem, however techniques have been developed to address this problem in classical model checking. These techniques include partial order reduction and abstraction, among others. Partial order reduction consists of trying to reduce the number of independent interleavings of concurrent processes, while abstraction attempts to simplify the model. These techniques have proved useful for classical model checking, however they unfortunately have limited applicability in model checking for robot motion.  
% e.g. ignore non-boolean variables in the model !!give citation!!

To address the state space explosion problem, we are presenting a method that does not reduce the number of states. It does however speed up the following search through the states. Instead of an algorithm that computes the globally optimal path, we instead propose an algorithm that takes the optimal path at each step according to the greedy paradigm. The performance of our proposed algorithm is then analysed in the context of robot motion planning and compared to the accepted algorithm from the literature. The algorithm is also applicable to classical model checking, however this is out of the scope of this work. 

\section{Outline}
\begin{description}
    \item[Chapter 2] We will first present all the theoretical results necessary for understanding the technique of model checking for motion planning. This will be self contained and does not require any prior knowledge in the field.
    \item[Chapter 3] We will review the current algorithm that is accepted and widely used and also our algorithm. We will review key differences in the procedures.
    \item[Chapter 4] We will test both algorithms on various formulas common in the field of motion planning for robot motion. The results are compared. %MAke a distinction between motion planning and task planning!! and stick to it!!!
    \item[Chapter 5] We will move on to more complex formulas including mixtures of motion planning and task planning. The results of the two algorithms are compared. 
    \item[Chapter 6] We draw conclusions and give recommendations of possible future work.
\end{description}

%which can be used for model checking, however we choose to only focus on LTL formulas. 