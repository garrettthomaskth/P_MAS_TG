\chapter{Introduction}
\section{Problem}
The use of formal methods, specifically \textit{model checking}, in control and task planning synthesis is a new and exciting research area. Formal methods are originally mathematical techniques to specifiy and verify the design of software and hardware \cite{clarke96}. Formal verification methods ensure that there are no bugs present in the software or hardware design which could cause unexpected behaviors. This is valuable because other debugging techniques such as simulation and testing only ensure that there are no problems with a given input. Bugs that go undetected can have disastrous effects, such as the explosion of the Ariane 5 rocket in 1996, which was caused by an exception being thrown when a 64-bit floating point number was converted to a 16-bit signed integer \cite{clarke99}. 

Model checking is an approach to formal verification which decides if a model of the program satisfies some behavior. These behaviors can be given as a temporal logic formula, commonly linear temporal logic (LTL) or computation tree logic (CTL). Since its advent, model checking under temporal logics has proven to be a very useful tool in software and hardware development. There are commercial and open source model checkers available \cite{holzmann03}, \cite{cimatti02} and many companies have their own in-house model checking programs. 

Two main advantages of model checking are that 1) it is completely autonomous; after the program is modelled and the behavior is formalized into temporal logic, the model checker is self sufficient and no longer requires user interaction and 2) in the situation when the model fails to satisfy the given formula, a counter example is given (\textit{why} the model does not satisfy the specification). 

It is obvious to see how the counter example gives valuable information for debugging purposes. This counter example, however, has also given rise to the field of model checking as a tool for control planning synthesis. In this field of motion and task planning, the model of the program is replaced by a model of a robot's (or robots') environment and the formula is replaced by the \textit{negation} of the desired robot motion and tasks. The realization that the double negative of the \textit{counter example} of the \textit{negation} of the desired motion was the desired motion is the basis of this field. Earlier works in this field have even used the same programs that were designed for classic model checking \cite{fainekos05}. 

Model checking, however, is not perfect. It suffers from what is known as the \textit{state-space explosion problem}. This is a phenomenon in which the number of states can quickly grow to an unmanageable number, rendering the model checking problem uncomputable. Neither classical model checking nor the application of model checking in motion planning is safe from the state-space explosion problem. However, techniques have been developed to address this problem in classical model checking. These techniques include partial order reduction and abstraction, among others. Partial order reduction consists of trying to reduce the number of independent interleavings of concurrent processes, while abstraction attempts to simplify the model. These techniques have proved useful for classical model checking, but they unfortunately have limited applicability in model checking for robot motion.  


To address the state-space explosion problem, we are presenting a method that speeds up the search through the states. Instead of an algorithm that computes the globally optimal path, we propose an algorithm that takes the optimal path at each step according to the greedy paradigm. These locally optimal paths are then concatenated together to form an approximation of the globally optimal path. The performance of our proposed algorithm is then analyzed in the context of robot motion planning and compared to the accepted algorithm from the literature. Our algorithm is also applicable to classical model checking. However, classical model checking is out of the scope of this work. 

\section{Outline}
\begin{description}
    \item[Chapter 2] We will first present all the theoretical results necessary for understanding the technique of model checking for motion planning. This will be self-contained and does not require any prior knowledge in the field.
    \item[Chapter 3] We will review the current, widely-used algorithm, as well as present our greedy algorithm. Furthermore, we will identify key differences in the procedures.
    \item[Chapter 4] We will theoretically analyze the behavior of both algorithms on various formulas common in the field of motion planning. We will then provide a case study for each category of formula and compare the computational time and the cost of the calculated path.
    \item[Chapter 5] We will move on to more complex formulas including mixtures of motion planning and task planning. The results of the two algorithms are compared. 
    \item[Chapter 6] We will draw conclusions and give recommendations of possible future work.
\end{description}
