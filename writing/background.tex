\chapter{Introduction}
\section{Problem}
The use of \textit{model checking} in control planning synthesis is a recent and exciting research area. This is however not what it was originally designed for. Model checking was designed to as a method for \textit{formal verification}. When designing one wants to make sure that it does what it is supposed to do, and there are no bugs in the program which will cause unexpected behaviors. These bugs can have disastrous effects, such as the explosion of the Ariane 5 rocket in 1996, which was caused by an exception being thrown when a 64-bit floating point number was converted to a 16-bit signed integer \cite{clarke99}. 

Simulation and testing a useful tools for finding these bugs, however they do not ensure that there are no bugs. One can only be sure that there are no bugs given the input that was simulated or tested. Formal verification on the other hand offers a guarantee of the correctness of the program. Model checking is an approach to formal verification which decides if a model of the program satisfies some behavior. These behaviors can be given as a temporal logic formula, commonly linear temporal logic (LTL) or computation tree logic (CTL). Since its advent symbolic model checking under temporal logics has proved to be a very useful tool in software development. There are commercial and open source model checkers available !!!give citation!!! and many companies work on their own in house model checking programs. 

Two main benefits of model checking are that 1) It is completely autonomous; after the program is modelled and the behavior is formalized into temporal logic, the model checker is self sufficient and requires no more user interference and 2) in the situation when the model fails to satisfy the given formula, a counter example is given (\textit{why} the model does not satisfy the specification). 

It is obvious to see how the counter example gives valuable information for debugging purposes. This counter example however has also given rise to the new and exciting field of model planning as a tool for control planning synthesis. In this field of motion and task planning, the model of the program is replaced by a model of the robot's environment and the formula is the \textit{negation} of the desired robot motion and tasks. The realization that the double negative of a \textit{counter example} of the \textit{negation} of the desired motion was in fact the desired motion is the basis of this field. Earlier works in this field have even used the same programs that were designed for classic model checking. %spin is used in blah blah blah papers

Model checking however is not perfect. It suffers from what is known as the \textit{state explosion} problem. This is a phenomenon in which with even not especially complex models or formulas, the number of states can grow to an unmanageable number rendering the model checking uncomputable. Neither classical model checking or the application of model checking in motion planning is safe from the state explosion problem, however techniques have been developed to address this problem in classical model checking. These techniques include partial order reduction and abstraction, among others. Partial order reduction consists of trying to reduce the number of independent interleavings of concurrent processes, while abstraction attempts to simplify the model e.g. ignore non-boolean variables in the model !!give citation!!. These techniques have proved useful for classical model checking, however unfortunately they have limited applicability in model checking for robot motion.  

To address the state space explosion problem, we are presenting a method that does not reduce the number of states, however it speeds up following search through the states. Instead of using an algorithm that computes the globally optimal path, we instead use an algorithm that takes the optimal path at each step according to the greedy paradigm. The performance of our proposed algorithm is then analysed in the context of robot motion planning. The algorithm is also applicable to classical model checking, however this is out of the scope of this work. 

\section{Outline}
\begin{enumerate}
    \item We will first present all the theoretical results necessary for understanding the technique of model checking for motion planning. This will be self contained and does not require any prior knowledge in the field.
    \item We will review the current algorithm that is accepted and widely used and also our algorithm. We will review key differences in the procedures.
    \item We will test both algorithms on various formulas common in the field of motion planning for robot motion. The results are compared. %MAke a distinction between motion planning and task planning!! and stick to it!!!
    \item We will move on to more complex formulas including mixtures of motion planning and task planning. The results of the two algorithms are compared. 
    \item We draw conclusions and give recommendation of future work.
\end{enumerate}

%which can be used for model checking, however we choose to only focus on LTL formulas. 